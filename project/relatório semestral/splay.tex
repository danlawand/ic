Splay tree é uma árvore binária de busca (ABB) com a propriedade de ser autoajustável, em que o último elemento acessado se torna a raiz da árvore~\cite{SleatorT1985}. Existem diferentes tipos de implementação, mas para o propósito deste trabalho utilizaremos a(s) seguinte(s) interface(s):  

\begin{verbatim}
    // splay.h
    Node makeSplay();
    void splay(Node);
    void join(Node, Node);
    void split(Node);
    Node maxSplay(Node);
    Node minSplay(Node);
    void reflectTree(Node);
\end{verbatim}


\begin{itemize}
    \item \texttt{makeSplay()}: retorna a raíz de uma splay tree com apenas um nó, tendo limite de tempo de $O(1)$.  
    \item \texttt{splay(v)}: recebe um nó \texttt{v}, tornando-o raíz da splay tree, com complexidade de $O(log_2 n)$ em tempo.  
    \item \texttt{join(v, w)}: recebe duas splay trees, \texttt{v} e \texttt{w}, fazendo com que \texttt{v} seja filho direito de \texttt{w}.  \textcolor{red}{(Coloco a seguinte parte?) Sabe-se que de início \texttt{w} não tem filho direito.} Tal rotina tem complexidade $O(1)$ em tempo.  
    \item \texttt{split(v)}: recebe o nó \texttt{v} de uma splay tree e o separa de seu filho direito, gerando uma nova splay tree enraizada no filho direito de \texttt{v}. A complexidade dessa rotina em tempo leva $O(1)$.  
    \item \texttt{maxSplay(v)}: retorna o nó mais profundo da splay tree em que \texttt{v} pertence, tendo complexidade de $O(log_2 n)$ em tempo.  
    \item \texttt{minSplay(v)}: retorna o nó menos profundo da splay tree em que \texttt{v} pertence, tendo complexidade de $O(log_2 n)$ em tempo.  
    \item \texttt{reflectTree(v)}: rotina em que inverte reciprocamente o filho direito com o esquerdo, tendo complexidade $O(1)$ em tempo.  


\end{itemize}

Os nós (\texttt{Node}), nessa implementação, não possuem campo chave (\texttt{Key}), tratando-se de uma ABB com chaves implícitas, ou seja, não utilizamos as chaves para realizar qualquer tipo de operação. Em uma splay tree tradicional, as chaves da sub-árvore esquerda são menores do que a de seu pai e as chaves da sub-árvore direita são maiores do que a de seu pai, e para encontrar determinado nó, passamos a chave como argumento.  
Em uma splay tree com chaves implícitas, considera-se que a chave de um nó é a posição dele num percurso in-ordem da árvore.  

Nessa implementação, não há inserção ou deleção de nós, pois as splay trees crescem com a rotina \texttt{join} e diminuem através da rotina \texttt{split}, que quebra a árvore em duas.  

\newpage

